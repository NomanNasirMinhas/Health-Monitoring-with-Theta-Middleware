"use strict";
/** @module transaction-converter */
exports.__esModule = true;
var converter_1 = require("@iota/converter");
var pad_1 = require("@iota/pad");
var transaction_1 = require("@iota/transaction");
var errors = require("../../errors");
var guards_1 = require("../../guards");
require("../../typed-array");
var types_1 = require("../../types");
/**
 * Converts a transaction object or a list of those into transaction trytes.
 *
 * @method asTransactionTrytes
 *
 * @param {Transaction | Transaction[]} transactions - Transaction object(s)
 *
 * @return {Trytes | Trytes[]} Transaction trytes
 */
function asTransactionTrytes(transactions) {
    var txTrytes = types_1.asArray(transactions).map(function (transaction) {
        return [
            transaction.signatureMessageFragment,
            transaction.address,
            converter_1.tritsToTrytes(pad_1.padTrits(transaction_1.VALUE_LENGTH)(converter_1.trytesToTrits(transaction.value))),
            pad_1.padTrytes(transaction_1.OBSOLETE_TAG_LENGTH / converter_1.TRYTE_WIDTH)(transaction.obsoleteTag),
            converter_1.tritsToTrytes(pad_1.padTrits(transaction_1.ISSUANCE_TIMESTAMP_LENGTH)(converter_1.trytesToTrits(transaction.timestamp))),
            converter_1.tritsToTrytes(pad_1.padTrits(transaction_1.CURRENT_INDEX_LENGTH)(converter_1.trytesToTrits(transaction.currentIndex))),
            converter_1.tritsToTrytes(pad_1.padTrits(transaction_1.LAST_INDEX_LENGTH)(converter_1.trytesToTrits(transaction.lastIndex))),
            transaction.bundle,
            transaction.trunkTransaction,
            transaction.branchTransaction,
            pad_1.padTrytes(transaction_1.OBSOLETE_TAG_LENGTH / converter_1.TRYTE_WIDTH)(transaction.tag || transaction.obsoleteTag),
            converter_1.tritsToTrytes(pad_1.padTrits(transaction_1.ATTACHMENT_TIMESTAMP_LENGTH)(converter_1.trytesToTrits(transaction.attachmentTimestamp))),
            converter_1.tritsToTrytes(pad_1.padTrits(transaction_1.ATTACHMENT_TIMESTAMP_LOWER_BOUND_LENGTH)(converter_1.trytesToTrits(transaction.attachmentTimestampLowerBound))),
            converter_1.tritsToTrytes(pad_1.padTrits(transaction_1.ATTACHMENT_TIMESTAMP_UPPER_BOUND_LENGTH)(converter_1.trytesToTrits(transaction.attachmentTimestampUpperBound))),
            transaction.nonce,
        ].join('');
    });
    return Array.isArray(transactions) ? txTrytes : txTrytes[0];
}
exports.asTransactionTrytes = asTransactionTrytes;
/**
 * Converts transaction trytes of 2673 trytes into a transaction object.
 *
 * @method asTransactionObject
 *
 * @param {Trytes} trytes - Transaction trytes
 *
 * @return {Transaction} Transaction object
 */
exports.asTransactionObject = function (trytes, hash) {
    if (!guards_1.isTrytesOfExactLength(trytes, transaction_1.TRANSACTION_LENGTH / converter_1.TRYTE_WIDTH)) {
        throw new Error(errors.INVALID_TRYTES);
    }
    for (var i = 2279; i < 2295; i++) {
        if (trytes.charAt(i) !== '9') {
            throw new Error(errors.INVALID_TRYTES);
        }
    }
    var trits = converter_1.trytesToTrits(trytes);
    return {
        hash: hash || converter_1.tritsToTrytes(transaction_1.transactionHash(trits)),
        signatureMessageFragment: trytes.slice(transaction_1.SIGNATURE_OR_MESSAGE_OFFSET / converter_1.TRYTE_WIDTH, transaction_1.SIGNATURE_OR_MESSAGE_LENGTH / converter_1.TRYTE_WIDTH),
        address: trytes.slice(transaction_1.ADDRESS_OFFSET / converter_1.TRYTE_WIDTH, (transaction_1.ADDRESS_OFFSET + transaction_1.ADDRESS_LENGTH) / converter_1.TRYTE_WIDTH),
        value: converter_1.value(trits.slice(transaction_1.VALUE_OFFSET, transaction_1.VALUE_OFFSET + transaction_1.VALUE_LENGTH)),
        obsoleteTag: trytes.slice(transaction_1.OBSOLETE_TAG_OFFSET / converter_1.TRYTE_WIDTH, (transaction_1.OBSOLETE_TAG_OFFSET + transaction_1.OBSOLETE_TAG_LENGTH) / converter_1.TRYTE_WIDTH),
        timestamp: converter_1.value(trits.slice(transaction_1.ISSUANCE_TIMESTAMP_OFFSET, transaction_1.ISSUANCE_TIMESTAMP_OFFSET + transaction_1.ISSUANCE_TIMESTAMP_LENGTH)),
        currentIndex: converter_1.value(trits.slice(transaction_1.CURRENT_INDEX_OFFSET, transaction_1.CURRENT_INDEX_OFFSET + transaction_1.CURRENT_INDEX_LENGTH)),
        lastIndex: converter_1.value(trits.slice(transaction_1.LAST_INDEX_OFFSET, transaction_1.LAST_INDEX_OFFSET + transaction_1.LAST_INDEX_LENGTH)),
        bundle: trytes.slice(transaction_1.BUNDLE_OFFSET / converter_1.TRYTE_WIDTH, (transaction_1.BUNDLE_OFFSET + transaction_1.BUNDLE_LENGTH) / converter_1.TRYTE_WIDTH),
        trunkTransaction: trytes.slice(transaction_1.TRUNK_TRANSACTION_OFFSET / converter_1.TRYTE_WIDTH, (transaction_1.TRUNK_TRANSACTION_OFFSET + transaction_1.TRUNK_TRANSACTION_LENGTH) / converter_1.TRYTE_WIDTH),
        branchTransaction: trytes.slice(transaction_1.BRANCH_TRANSACTION_OFFSET / converter_1.TRYTE_WIDTH, (transaction_1.BRANCH_TRANSACTION_OFFSET + transaction_1.BRANCH_TRANSACTION_LENGTH) / converter_1.TRYTE_WIDTH),
        tag: trytes.slice(transaction_1.TAG_OFFSET / converter_1.TRYTE_WIDTH, (transaction_1.TAG_OFFSET + transaction_1.TAG_LENGTH) / converter_1.TRYTE_WIDTH),
        attachmentTimestamp: converter_1.value(trits.slice(transaction_1.ATTACHMENT_TIMESTAMP_OFFSET, transaction_1.ATTACHMENT_TIMESTAMP_OFFSET + transaction_1.ATTACHMENT_TIMESTAMP_LENGTH)),
        attachmentTimestampLowerBound: converter_1.value(trits.slice(transaction_1.ATTACHMENT_TIMESTAMP_LOWER_BOUND_OFFSET, transaction_1.ATTACHMENT_TIMESTAMP_LOWER_BOUND_OFFSET + transaction_1.ATTACHMENT_TIMESTAMP_LOWER_BOUND_LENGTH)),
        attachmentTimestampUpperBound: converter_1.value(trits.slice(transaction_1.ATTACHMENT_TIMESTAMP_UPPER_BOUND_OFFSET, transaction_1.ATTACHMENT_TIMESTAMP_UPPER_BOUND_OFFSET + transaction_1.ATTACHMENT_TIMESTAMP_UPPER_BOUND_LENGTH)),
        nonce: trytes.slice(transaction_1.TRANSACTION_NONCE_OFFSET / converter_1.TRYTE_WIDTH, (transaction_1.TRANSACTION_NONCE_OFFSET + transaction_1.TRANSACTION_NONCE_LENGTH) / converter_1.TRYTE_WIDTH)
    };
};
/**
 * Converts a list of transaction trytes into list of transaction objects.
 * Accepts a list of hashes and returns a mapper. In cases hashes are given,
 * the mapper function map them to converted objects.
 *
 * @method asTransactionObjects
 *
 * @param {Hash[]} [hashes] - Optional list of known hashes.
 * Known hashes are directly mapped to transaction objects,
 * otherwise all hashes are being recalculated.
 *
 * @return {Function} {@link #module_transaction.transactionObjectsMapper `transactionObjectsMapper`}
 */
exports.asTransactionObjects = function (hashes) {
    /**
     * Maps the list of given hashes to a list of converted transaction objects.
     *
     * @method transactionObjectsMapper
     *
     * @param {Trytes[]} trytes - List of transaction trytes to convert
     *
     * @return {Transaction[]} List of transaction objects with hashes
     */
    return function transactionObjectsMapper(trytes) {
        return trytes.map(function (tryteString, i) { return exports.asTransactionObject(tryteString, hashes[i]); });
    };
};
exports.asFinalTransactionTrytes = function (transactions) {
    return asTransactionTrytes(transactions).slice().reverse();
};
exports.transactionObject = function (trytes) {
    /* tslint:disable-next-line:no-console */
    console.warn('`transactionObject` has been renamed to `asTransactionObject`');
    return exports.asTransactionObject(trytes);
};
exports.transactionTrytes = function (transaction) {
    /* tslint:disable-next-line:no-console */
    console.warn('`transactionTrytes` has been renamed to `asTransactionTrytes`');
    return asTransactionTrytes(transaction);
};
//# sourceMappingURL=index.js.map