"use strict";
/** @module bundle */
exports.__esModule = true;
var converter_1 = require("@iota/converter");
var kerl_1 = require("@iota/kerl");
var signing_1 = require("@iota/signing");
var errors = require("../../errors");
require("../../typed-array");
var transaction_1 = require("@iota/transaction");
/**
 * Creates a bundle with given transaction entries.
 *
 * @method createBundle
 *
 * @param {BundleEntry[]} [entries=[]] - Entries of single or multiple transactions with the same address
 *
 * @return {Int8Array[]} List of transactions in the bundle
 */
exports.createBundle = function (entries) {
    if (entries === void 0) { entries = []; }
    return entries.reduce(function (bundle, entry) { return exports.addEntry(bundle, entry); }, new Int8Array(0));
};
/**
 * Adds given transaction entry to a bundle.
 *
 * @method addEntry
 *
 * @param {object} entry - Entry of a single or multiple transactions with the same address.
 * @param {Int8Array} entry.address - Address.
 * @param {Int8Array} entry.value - Value to transfer in iotas.
 * @param {Int8Array} [entry.signatureOrMessage] - Signature or message fragment(s).
 * @param {Int8Array} [entry.timestamp] - Issuance timestamp (in seconds).
 * @param {Int8Array} [entry.tag] - Optional Tag, **Deprecated**.
 * @param {Int8Array} bundle - Bundle buffer.
 *
 * @return {Int8Array} Bundle copy with new entries.
 */
exports.addEntry = function (bundle, entry) {
    var signatureOrMessage = entry.signatureOrMessage, 
    // extraDataDigest,
    address = entry.address, value = entry.value, obsoleteTag = entry.obsoleteTag, issuanceTimestamp = entry.issuanceTimestamp, tag = entry.tag;
    /*
    warning(
        signatureOrMessage && !isNullTrits(signatureOrMessage),
        'Deprecation warning: \n' +
            ' - Use of "signatureOrMessage" field before bundle finalization is deprecated and will be removed in v1.0.0. \n'
    )

    warning(
        obsoleteTag && !isNullTrits(obsoleteTag),
        'Deprecation warning: \n' +
            ' - "obseleteTag" field is deprecated and will be removed in implementation of final design. \n' +
            ' - Use of "obsoleteTag" or "tag" field before bundle finalization is deprecated and will be removed in v1.0.0. \n'
    )

    warning(
        tag && !isNullTrits(tag),
        'Deprecation warning: \n' +
            ' - Use of "tag" field before bundle finalization is deprecated and will be removed in v1.0.0. \n'
    )
    */
    if (!transaction_1.isMultipleOfTransactionLength(bundle.length)) {
        throw new RangeError(errors.ILLEGAL_TRANSACTION_BUFFER_LENGTH);
    }
    if (signatureOrMessage &&
        (signatureOrMessage.length === 0 || signatureOrMessage.length % transaction_1.SIGNATURE_OR_MESSAGE_LENGTH !== 0)) {
        throw new RangeError(errors.ILLEGAL_SIGNATURE_OR_MESSAGE_LENGTH);
    }
    if (address && address.length !== transaction_1.ADDRESS_LENGTH) {
        throw new RangeError(errors.ILLEGAL_ADDRESS_LENGTH);
    }
    if (value && value.length > transaction_1.VALUE_LENGTH) {
        throw new RangeError(errors.ILLEGAL_VALUE_LENGTH);
    }
    if (obsoleteTag && obsoleteTag.length > transaction_1.OBSOLETE_TAG_LENGTH) {
        throw new RangeError(errors.ILLEGAL_OBSOLETE_TAG_LENGTH);
    }
    if (issuanceTimestamp && issuanceTimestamp.length > transaction_1.ISSUANCE_TIMESTAMP_LENGTH) {
        throw new RangeError(errors.ILLEGAL_ISSUANCE_TIMESTAMP_LENGTH);
    }
    if (tag && tag.length > transaction_1.TAG_LENGTH) {
        throw new RangeError(errors.ILLEGAL_TAG_LENGTH);
    }
    var signatureOrMessageCopy = signatureOrMessage
        ? signatureOrMessage.slice()
        : new Int8Array(transaction_1.SIGNATURE_OR_MESSAGE_LENGTH);
    var numberOfFragments = signatureOrMessageCopy.length / transaction_1.SIGNATURE_OR_MESSAGE_LENGTH;
    var bundleCopy = new Int8Array(bundle.length + numberOfFragments * transaction_1.TRANSACTION_LENGTH);
    var currentIndexBuffer = bundle.length > 0 ? signing_1.increment(transaction_1.lastIndex(bundle)) : new Int8Array(transaction_1.LAST_INDEX_LENGTH);
    var lastIndexBuffer = currentIndexBuffer.slice();
    var fragmentIndex = 0;
    bundleCopy.set(bundle.slice());
    // Create and append transactions to the bundle.
    for (var offset = bundle.length; offset < bundleCopy.length; offset += transaction_1.TRANSACTION_LENGTH) {
        var signatureOrMessageCopyFragment = signatureOrMessageCopy.subarray(fragmentIndex * transaction_1.SIGNATURE_OR_MESSAGE_LENGTH, (fragmentIndex + 1) * transaction_1.SIGNATURE_OR_MESSAGE_LENGTH);
        bundleCopy.set(signatureOrMessageCopyFragment, offset + transaction_1.SIGNATURE_OR_MESSAGE_OFFSET);
        if (address) {
            bundleCopy.set(address, offset + transaction_1.ADDRESS_OFFSET);
        }
        if (value && fragmentIndex === 0) {
            bundleCopy.set(value, offset + transaction_1.VALUE_OFFSET);
        }
        if (obsoleteTag) {
            bundleCopy.set(obsoleteTag, offset + transaction_1.OBSOLETE_TAG_OFFSET);
        }
        if (issuanceTimestamp) {
            bundleCopy.set(issuanceTimestamp, offset + transaction_1.ISSUANCE_TIMESTAMP_OFFSET);
        }
        bundleCopy.set(currentIndexBuffer, offset + transaction_1.CURRENT_INDEX_OFFSET);
        if (tag) {
            bundleCopy.set(tag, offset + transaction_1.TAG_OFFSET);
        }
        lastIndexBuffer.set(currentIndexBuffer.slice());
        currentIndexBuffer.set(signing_1.increment(currentIndexBuffer));
        fragmentIndex++;
    }
    for (var offset = transaction_1.LAST_INDEX_OFFSET; offset < bundleCopy.length; offset += transaction_1.TRANSACTION_LENGTH) {
        bundleCopy.set(lastIndexBuffer, offset);
    }
    return bundleCopy;
};
/**
 * Finalizes a bundle by calculating the bundle hash.
 *
 * @method finalizeBundle
 *
 * @param {Int8Array} bundle - Bundle transaction trits
 *
 * @param {number} [numberOfFragments=3]
 *
 * @return {Int8Array} List of transactions in the finalized bundle
 */
exports.finalizeBundle = function (bundle, numberOfFragments) {
    if (numberOfFragments === void 0) { numberOfFragments = 3; }
    if (!transaction_1.isMultipleOfTransactionLength(bundle.length)) {
        throw new Error(errors.ILLEGAL_TRANSACTION_BUFFER_LENGTH);
    }
    var sponge = new kerl_1["default"]();
    var bundleCopy = bundle.slice();
    var bundleHash = new Int8Array(transaction_1.BUNDLE_LENGTH);
    // This block recomputes bundle hash by incrementing `obsoleteTag` field of first transaction in the bundle.
    // Normalized bundle should NOT contain value `13`.
    while (true) {
        // Absorb essence trits to squeeze bundle hash.
        for (var offset = 0; offset < bundle.length; offset += transaction_1.TRANSACTION_LENGTH) {
            sponge.absorb(transaction_1.transactionEssence(bundleCopy, offset), 0, transaction_1.TRANSACTION_ESSENCE_LENGTH);
        }
        // Set new bundle hash value.
        sponge.squeeze(bundleHash, 0, transaction_1.BUNDLE_LENGTH);
        // Stop mutation if essence results to secure bundle.
        if (signing_1.normalizedBundle(bundleHash).slice(0, numberOfFragments * signing_1.NORMALIZED_FRAGMENT_LENGTH).indexOf(signing_1.MAX_TRYTE_VALUE /* 13 */) === -1) {
            // Essence results to secure bundle.
            break;
        }
        // Essence results to insecure bundle. (Normalized bundle hash contains value `13`.)
        bundleCopy.set(signing_1.increment(bundleCopy.subarray(transaction_1.OBSOLETE_TAG_OFFSET, transaction_1.OBSOLETE_TAG_OFFSET + transaction_1.OBSOLETE_TAG_LENGTH)), transaction_1.OBSOLETE_TAG_OFFSET);
        sponge.reset();
    }
    // Set bundle field of each transaction.
    for (var offset = transaction_1.BUNDLE_OFFSET; offset < bundle.length; offset += transaction_1.TRANSACTION_LENGTH) {
        bundleCopy.set(bundleHash, offset);
    }
    return bundleCopy;
};
/**
 * Adds signature message fragments to transactions in a bundle starting at offset.
 *
 * @method addSignatureOrMessage
 *
 * @param {Int8Array} bundle - Bundle buffer.
 * @param {Int8Array} signatureOrMessage - Signature or message to add.
 * @param {number} index - Transaction index as entry point for signature or message fragments.
 *
 * @return {Int8Array} List of transactions in the updated bundle
 */
exports.addSignatureOrMessage = function (bundle, signatureOrMessage, index) {
    if (!transaction_1.isMultipleOfTransactionLength(bundle.length)) {
        throw new Error(errors.ILLEGAL_TRANSACTION_BUFFER_LENGTH);
    }
    if (!Number.isInteger(index)) {
        throw new TypeError(errors.ILLEGAL_TRANSACTION_INDEX);
    }
    if (signatureOrMessage.length === 0 || signatureOrMessage.length % transaction_1.SIGNATURE_OR_MESSAGE_LENGTH !== 0) {
        throw new RangeError(errors.ILLEGAL_SIGNATURE_OR_MESSAGE_LENGTH);
    }
    if (index < 0 || bundle.length - index - signatureOrMessage.length / transaction_1.SIGNATURE_OR_MESSAGE_LENGTH < 0) {
        throw new RangeError(errors.ILLEGAL_TRANSACTION_INDEX);
    }
    var bundleCopy = bundle.slice();
    var numberOfFragmentsToAdd = signatureOrMessage.length / transaction_1.SIGNATURE_OR_MESSAGE_LENGTH;
    for (var i = 0; i < numberOfFragmentsToAdd; i++) {
        bundleCopy.set(signatureOrMessage.slice(i * transaction_1.SIGNATURE_OR_MESSAGE_LENGTH, (i + 1) * transaction_1.SIGNATURE_OR_MESSAGE_LENGTH), (index + i) * transaction_1.TRANSACTION_LENGTH + transaction_1.SIGNATURE_OR_MESSAGE_OFFSET);
    }
    return bundleCopy;
};
/**
 * Sums up transaction values in a bundle starting at offset.
 *
 * @method valueSum
 *
 * @param {Int8Array} bundle - Bundle buffer.
 * @param {number} offset - Offset from the start of the bundle buffer.
 * @param {number} length - Length of transactions in which values should be summed.
 *
 * @return {number} Total value of 'length' transactions in the bundle starting at offset.
 */
exports.valueSum = function (buffer, offset, length) {
    if (!transaction_1.isMultipleOfTransactionLength(buffer.length)) {
        throw new RangeError(errors.ILLEGAL_TRANSACTION_BUFFER_LENGTH);
    }
    if (!Number.isInteger(offset)) {
        throw new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET);
    }
    if (!transaction_1.isMultipleOfTransactionLength(offset)) {
        throw new RangeError(errors.ILLEGAL_TRANSACTION_OFFSET);
    }
    if (!Number.isInteger(length)) {
        throw new TypeError(errors.ILLEGAL_BUNDLE_LENGTH);
    }
    if (!transaction_1.isMultipleOfTransactionLength(length)) {
        throw new RangeError(errors.ILLEGAL_BUNDLE_LENGTH);
    }
    var sum = 0;
    for (var bundleOffset = 0; bundleOffset < length; bundleOffset += transaction_1.TRANSACTION_LENGTH) {
        sum += converter_1.tritsToValue(transaction_1.value(buffer, offset + bundleOffset));
    }
    return sum;
};
//# sourceMappingURL=index.js.map